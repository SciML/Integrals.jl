<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Numerically Solving Integrals · Integrals.jl</title><meta name="title" content="Numerically Solving Integrals · Integrals.jl"/><meta property="og:title" content="Numerically Solving Integrals · Integrals.jl"/><meta property="twitter:title" content="Numerically Solving Integrals · Integrals.jl"/><meta name="description" content="Documentation for Integrals.jl."/><meta property="og:description" content="Documentation for Integrals.jl."/><meta property="twitter:description" content="Documentation for Integrals.jl."/><meta property="og:url" content="https://docs.sciml.ai/Integrals/stable/tutorials/numerical_integrals/"/><meta property="twitter:url" content="https://docs.sciml.ai/Integrals/stable/tutorials/numerical_integrals/"/><link rel="canonical" href="https://docs.sciml.ai/Integrals/stable/tutorials/numerical_integrals/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Integrals.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Integrals.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Integrals.jl: Unified Integral Approximation Interface</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Numerically Solving Integrals</a><ul class="internal"><li><a class="tocitem" href="#One-dimensional-integrals"><span>One-dimensional integrals</span></a></li><li><a class="tocitem" href="#Infinity-handling"><span>Infinity handling</span></a></li></ul></li><li><a class="tocitem" href="../differentiating_integrals/">Differentiating Integrals</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/IntegralProblem/">Integral Problems</a></li><li><a class="tocitem" href="../../basics/IntegralFunction/">Integral Functions</a></li><li><a class="tocitem" href="../../basics/SampledIntegralProblem/">Integrating pre-sampled data</a></li><li><a class="tocitem" href="../../basics/solve/">Common Solver Options (Solve Keyword Arguments)</a></li><li><a class="tocitem" href="../../basics/FAQ/">Frequently Asked Questions</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../../solvers/IntegralSolvers/">Integral Solver Algorithms</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Numerically Solving Integrals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Numerically Solving Integrals</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/Integrals.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/Integrals.jl/blob/master/docs/src/tutorials/numerical_integrals.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Numerically-Solving-Integrals"><a class="docs-heading-anchor" href="#Numerically-Solving-Integrals">Numerically Solving Integrals</a><a id="Numerically-Solving-Integrals-1"></a><a class="docs-heading-anchor-permalink" href="#Numerically-Solving-Integrals" title="Permalink"></a></h1><p>For basic multidimensional quadrature, we can construct and solve a <code>IntegralProblem</code>. The integral we want to evaluate is:</p><p class="math-container">\[\int_1^3\int_1^3\int_1^3 \sum_1^3 \sin(u_i) du_1du_2du_3.\]</p><p>We can numerically approximate this integral:</p><pre><code class="language-julia hljs">using Integrals
f(u, p) = sum(sin.(u))
domain = (ones(3), 3ones(3)) # (lb, ub)
prob = IntegralProblem(f, domain)
sol = solve(prob, HCubatureJL(); reltol = 1e-3, abstol = 1e-3)
sol.u</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">18.363538253324492</code></pre><p>where the first argument of <code>IntegralProblem</code> is the integrand, the second argument is the lower bound, and the third argument is the upper bound. <code>p</code> are the parameters of the integrand. In this case, there are no parameters, but still <code>f</code> must be defined as <code>f(x,p)</code> and <strong>not</strong> <code>f(x)</code>. For an example with parameters, see the next tutorial. The first argument of <code>solve</code> is the problem we are solving, the second is an algorithm to solve the problem with. Then there are keywords which provides details how the algorithm should work, in this case tolerances how precise the numerical approximation should be.</p><p>We can also evaluate multiple integrals at once. We could create two <code>IntegralProblem</code>s for this, but that is wasteful if the integrands share a lot of computation. For example, we also want to evaluate:</p><p class="math-container">\[\int_1^3\int_1^3\int_1^3 \sum_1^3 \cos(u_i) du_1du_2du_3.\]</p><pre><code class="language-julia hljs">using Integrals
f(u, p) = [sum(sin.(u)), sum(cos.(u))]
domain = (ones(3), 3ones(3)) # (lb, ub)
prob = IntegralProblem(f, domain)
sol = solve(prob, HCubatureJL(); reltol = 1e-3, abstol = 1e-3)
sol.u</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 18.363538253324492
 -8.40421200641804</code></pre><p>Another way to think about this is that the integrand is now a vector valued function. In general, we should be able to integrate any type that is in a vector space and supports addition and scalar multiplication, although Integrals.jl allows scalars and arrays. In the above example, the integrand was defined out-of-position. This means that a new output vector is created every time the function <code>f</code> is called. If we do not  want these allocations, we can also define <code>f</code> in-position.</p><pre><code class="language-julia hljs">using Integrals, Cubature
function f(y, u, p)
    y[1] = sum(sin.(u))
    y[2] = sum(cos.(u))
end
prototype = zeros(2)
domain = (ones(3), 3ones(3)) # (lb, ub)
prob = IntegralProblem(IntegralFunction(f, prototype), domain)
sol = solve(prob, CubatureJLh(); reltol = 1e-3, abstol = 1e-3)
sol.u</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 18.363538253324492
 -8.40421200641804</code></pre><p>where <code>y</code> is a cache to store the evaluation of the integrand and <code>prototype</code> is an instance of <code>y</code> with the desired type and shape. We needed to change the algorithm to <code>CubatureJLh()</code> because <code>HCubatureJL()</code> does not support in-position under the hood. <code>f</code> evaluates the integrand at a certain point, but most adaptive quadrature algorithms need to evaluate the integrand at multiple points in each step of the algorithm. We would thus often like to parallelize the computation. The batch interface allows us to compute multiple points at once. For example, here we do allocation-free multithreading with Cubature.jl:</p><pre><code class="language-julia hljs">using Integrals, Cubature, Base.Threads
function f(y, u, p)
    Threads.@threads for i in 1:size(u, 2)
        y[1, i] = sum(sin, @view(u[:, i]))
        y[2, i] = sum(cos, @view(u[:, i]))
    end
end
prototype = zeros(2, 0)
domain = (ones(3), 3ones(3)) # (lb, ub)
prob = IntegralProblem(BatchIntegralFunction(f, prototype), domain)
sol = solve(prob, CubatureJLh(); reltol = 1e-3, abstol = 1e-3)
sol.u</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 18.363538253324492
 -8.40421200641804</code></pre><p>Both <code>u</code> and <code>y</code> changed from vectors to matrices, where each column is respectively a point the integrand is evaluated at or the evaluation of the integrand at the corresponding point. The <code>prototype</code> now has an extra dimension for batching that can be of size zero. Try to create yourself an out-of-position version of the above problem. For the full details of the batching interface, see the <a href="../../basics/IntegralProblem/#prob">problem page</a>.</p><p>If we would like to compare the results against Cuba.jl&#39;s <code>Cuhre</code> method, then the change is a one-argument change:</p><pre><code class="language-julia hljs">using Integrals
using Cuba
f(u, p) = sum(sin.(u))
domain = (ones(3), 3ones(3)) # (lb, ub)
prob = IntegralProblem(f, domain)
sol = solve(prob, CubaCuhre(); reltol = 1e-3, abstol = 1e-3)
sol.u</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">18.36353762962854</code></pre><p>However, <code>Cuhre</code> does not support vector valued integrands. The <a href="../../solvers/IntegralSolvers/#solvers">solvers page</a> gives an overview of which arguments each algorithm can handle.</p><h2 id="One-dimensional-integrals"><a class="docs-heading-anchor" href="#One-dimensional-integrals">One-dimensional integrals</a><a id="One-dimensional-integrals-1"></a><a class="docs-heading-anchor-permalink" href="#One-dimensional-integrals" title="Permalink"></a></h2><p>Integrals.jl also has specific solvers for integrals in a single dimension, such as <code>QuadGKJL</code>. For example, we can create our own sine function by integrating the cosine function from 0 to x.</p><pre><code class="language-julia hljs">using Integrals
my_sin(x) = solve(IntegralProblem((x, p) -&gt; cos(x), (0.0, x)), QuadGKJL()).u
x = 0:0.1:(2 * pi)
@. my_sin(x) ≈ sin(x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">63-element BitVector:
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 ⋮
 1
 1
 1
 1
 1
 1
 1
 1
 1</code></pre><h2 id="Infinity-handling"><a class="docs-heading-anchor" href="#Infinity-handling">Infinity handling</a><a id="Infinity-handling-1"></a><a class="docs-heading-anchor-permalink" href="#Infinity-handling" title="Permalink"></a></h2><p>Integrals.jl can also handle infinite integration bounds. For infinite upper bounds <span>$u$</span> is substituted with <span>$a+\frac{t}{1-t}$</span>, and the integral is thus transformed to:</p><p class="math-container">\[\int_a^\infty f(u)du = \int_0^1 f\left(a+\frac{t}{1-t}\right)\frac{1}{(1-t)^2}dt\]</p><p>Integrals with an infinite lower bound are handled in the same way. If both upper and lower bound are infinite, <span>$u$</span> is substituted with <span>$\frac{t}{1-t^2}$</span>,</p><p class="math-container">\[\int_{-\infty}^\infty f(u)du = \int_{-1}^1 f\left(\frac{t}{1-t^2}\right)\frac{1+t^2}{(1-t^2)^2}dt\]</p><p>For multidimensional integrals, each variable with infinite bounds is substituted the same way. The details of the math behind these transforms can be found <a href="https://en.wikipedia.org/wiki/Integration_by_substitution#Substitution_for_multiple_variables">here</a>.</p><p>As an example, let us integrate the standard bivariate normal probability distribution over the area above the horizontal axis, which should be equal to <span>$0.5$</span>.</p><pre><code class="language-julia hljs">using Distributions
using Integrals
dist = MvNormal(ones(2))
f = (x, p) -&gt; pdf(dist, x)
domain = ([-Inf, 0.0], [Inf, Inf]) # (lb, ub)
prob = IntegralProblem(f, domain)
solve(prob, HCubatureJL(), reltol = 1e-3, abstol = 1e-3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
u: 0.49995156348205083</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Integrals.jl: Unified Integral Approximation Interface</a><a class="docs-footer-nextpage" href="../differentiating_integrals/">Differentiating Integrals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 22 February 2024 04:57">Thursday 22 February 2024</span>. Using Julia version 1.10.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
