<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Integral Solver Algorithms · Integrals.jl</title><meta name="title" content="Integral Solver Algorithms · Integrals.jl"/><meta property="og:title" content="Integral Solver Algorithms · Integrals.jl"/><meta property="twitter:title" content="Integral Solver Algorithms · Integrals.jl"/><meta name="description" content="Documentation for Integrals.jl."/><meta property="og:description" content="Documentation for Integrals.jl."/><meta property="twitter:description" content="Documentation for Integrals.jl."/><meta property="og:url" content="https://docs.sciml.ai/Integrals/stable/solvers/IntegralSolvers/"/><meta property="twitter:url" content="https://docs.sciml.ai/Integrals/stable/solvers/IntegralSolvers/"/><link rel="canonical" href="https://docs.sciml.ai/Integrals/stable/solvers/IntegralSolvers/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Integrals.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Integrals.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Integrals.jl: Unified Integral Approximation Interface</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/numerical_integrals/">Numerically Solving Integrals</a></li><li><a class="tocitem" href="../../tutorials/differentiating_integrals/">Differentiating Integrals</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/IntegralProblem/">Integral Problems</a></li><li><a class="tocitem" href="../../basics/IntegralFunction/">Integral Functions</a></li><li><a class="tocitem" href="../../basics/SampledIntegralProblem/">Integrating pre-sampled data</a></li><li><a class="tocitem" href="../../basics/solve/">Common Solver Options (Solve Keyword Arguments)</a></li><li><a class="tocitem" href="../../basics/FAQ/">Frequently Asked Questions</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li class="is-active"><a class="tocitem" href>Integral Solver Algorithms</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solvers</a></li><li class="is-active"><a href>Integral Solver Algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Integral Solver Algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/Integrals.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/Integrals.jl/blob/master/docs/src/solvers/IntegralSolvers.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="solvers"><a class="docs-heading-anchor" href="#solvers">Integral Solver Algorithms</a><a id="solvers-1"></a><a class="docs-heading-anchor-permalink" href="#solvers" title="Permalink"></a></h1><p>The following algorithms are available:</p><ul><li><code>QuadGKJL</code>: Uses QuadGK.jl, which supports one-dimensional integration of scalar and array-valued integrands with in-place or batched forms. Integrands that are both in-place and batched are implemented in the wrapper but are not supported under the hood.</li><li><code>HCubatureJL</code>: Uses HCubature.jl, which supports scalar and array-valued integrands and works best in low dimensions, e.g. ≤ 8. In-place integrands are implemented in the wrapper but are not supported under the hood. Batching is not supported.</li><li><code>VEGAS</code>: Uses MonteCarloIntegration.jl, which requires scalar, <code>Float64</code>-valued integrands and works in any number of dimensions.</li><li><code>VEGASMC</code>: Uses MCIntegration.jl. Requires <code>using MCIntegration</code>. Doesn&#39;t support batching.</li><li><code>CubatureJLh</code>: h-Cubature from Cubature.jl. Requires <code>using Cubature</code>.</li><li><code>CubatureJLp</code>: p-Cubature from Cubature.jl. Requires <code>using Cubature</code>.</li><li><code>CubaVegas</code>: Vegas from Cuba.jl. Requires <code>using Cuba</code>.</li><li><code>CubaSUAVE</code>: SUAVE from Cuba.jl. Requires <code>using Cuba</code>.</li><li><code>CubaDivonne</code>: Divonne from Cuba.jl. Requires <code>using Cuba</code>. Works only for <code>&gt;1</code>-dimensional integrations.</li><li><code>CubaCuhre</code>: Cuhre from Cuba.jl. Requires <code>using Cuba</code>. Works only for <code>&gt;1</code>-dimensional integrations.</li><li><code>GaussLegendre</code>: Performs fixed-order Gauss-Legendre quadrature. Requires <code>using FastGaussQuadrature</code>.</li><li><code>QuadratureRule</code>: Accepts a user-defined function that returns nodes and weights.</li><li><code>ArblibJL</code>: real- and complex-valued univariate integration of holomorphic and meromorphic functions from Arblib.jl. Requires <code>using Arblib</code>.</li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Integrals.QuadGKJL" href="#Integrals.QuadGKJL"><code>Integrals.QuadGKJL</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuadGKJL(; order = 7, norm = norm, buffer = nothing)</code></pre><p>One-dimensional Gauss-Kronrod integration from QuadGK.jl. This method also takes the optional arguments <code>order</code> and <code>norm</code>. Which are the order of the integration rule and the norm for calculating the error, respectively. Lastly, the <code>buffer</code> keyword, if set (e.g. <code>buffer=true</code>), will allocate a buffer to reuse for multiple integrals and may require evaluating the integrand unless an <code>integrand_prototype</code> is provided. Unlike the <code>segbuf</code> keyword to <code>quadgk</code>, you do not allocate the buffer as this is handled automatically.</p><p><strong>References</strong></p><pre><code class="language-tex hljs">@article{laurie1997calculation,
title={Calculation of Gauss-Kronrod quadrature rules},
author={Laurie, Dirk},
journal={Mathematics of Computation},
volume={66},
number={219},
pages={1133--1145},
year={1997}
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Integrals.jl/blob/409acc3a639c84cf066d448f1491c5027c15a32c/src/algorithms.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Integrals.HCubatureJL" href="#Integrals.HCubatureJL"><code>Integrals.HCubatureJL</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HCubatureJL(; norm=norm, initdiv=1, buffer = nothing)</code></pre><p>Multidimensional &quot;h-adaptive&quot; integration from HCubature.jl. This method also takes the optional arguments <code>initdiv</code> and <code>norm</code>. Which are the initial number of segments each dimension of the integration domain is divided into, and the norm for calculating the error, respectively. Lastly, the <code>buffer</code> keyword, if set (e.g. <code>buffer=true</code>), will allocate a buffer to reuse for multiple integrals and may require evaluating the integrand unless an <code>integrand_prototype</code> is provided. Unlike the <code>buffer</code> keyword to <code>hcubature/hquadrature</code>, you do not allocate the buffer as this is handled automatically.</p><p><strong>References</strong></p><pre><code class="language-tex hljs">@article{genz1980remarks,
title={Remarks on algorithm 006: An adaptive algorithm for numerical integration over an N-dimensional rectangular region},
author={Genz, Alan C and Malik, Aftab Ahmad},
journal={Journal of Computational and Applied mathematics},
volume={6},
number={4},
pages={295--302},
year={1980},
publisher={Elsevier}
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Integrals.jl/blob/409acc3a639c84cf066d448f1491c5027c15a32c/src/algorithms.jl#L34-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Integrals.CubatureJLp" href="#Integrals.CubatureJLp"><code>Integrals.CubatureJLp</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CubatureJLp(; error_norm=Cubature.INDIVIDUAL)</code></pre><p>Multidimensional p-adaptive integration from Cubature.jl. This method is based on repeatedly doubling the degree of the cubature rules, until convergence is achieved. The used cubature rule is a tensor product of Clenshaw–Curtis quadrature rules. <code>error_norm</code> specifies the convergence criterion  for vector valued integrands. Defaults to <code>Cubature.INDIVIDUAL</code>, other options are <code>Cubature.PAIRED</code>, <code>Cubature.L1</code>, <code>Cubature.L2</code>, or <code>Cubature.LINF</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Integrals.jl/blob/409acc3a639c84cf066d448f1491c5027c15a32c/src/algorithms_extension.jl#L218-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Integrals.CubatureJLh" href="#Integrals.CubatureJLh"><code>Integrals.CubatureJLh</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CubatureJLh(; error_norm=Cubature.INDIVIDUAL)</code></pre><p>Multidimensional h-adaptive integration from Cubature.jl. <code>error_norm</code> specifies the convergence criterion  for vector valued integrands. Defaults to <code>Cubature.INDIVIDUAL</code>, other options are <code>Cubature.PAIRED</code>, <code>Cubature.L1</code>, <code>Cubature.L2</code>, or <code>Cubature.LINF</code>.</p><p><strong>References</strong></p><pre><code class="language-tex hljs">@article{genz1980remarks,
title={Remarks on algorithm 006: An adaptive algorithm for numerical integration over an N-dimensional rectangular region},
author={Genz, Alan C and Malik, Aftab Ahmad},
journal={Journal of Computational and Applied mathematics},
volume={6},
number={4},
pages={295--302},
year={1980},
publisher={Elsevier}
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Integrals.jl/blob/409acc3a639c84cf066d448f1491c5027c15a32c/src/algorithms_extension.jl#L186-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Integrals.VEGAS" href="#Integrals.VEGAS"><code>Integrals.VEGAS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VEGAS(; nbins = 100, ncalls = 1000, debug=false, seed = nothing)</code></pre><p>Multidimensional adaptive Monte Carlo integration from MonteCarloIntegration.jl. Importance sampling is used to reduce variance. This method also takes three optional arguments <code>nbins</code>, <code>ncalls</code> and <code>debug</code> which are the initial number of bins each dimension of the integration domain is divided into, the number of function calls per iteration of the algorithm, and whether debug info should be printed, respectively.</p><p><strong>Limitations</strong></p><p>This algorithm can only integrate <code>Float64</code>-valued functions</p><p><strong>References</strong></p><pre><code class="language-tex hljs">@article{lepage1978new,
title={A new algorithm for adaptive multidimensional integration},
author={Lepage, G Peter},
journal={Journal of Computational Physics},
volume={27},
number={2},
pages={192--203},
year={1978},
publisher={Elsevier}
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Integrals.jl/blob/409acc3a639c84cf066d448f1491c5027c15a32c/src/algorithms.jl#L71-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Integrals.VEGASMC" href="#Integrals.VEGASMC"><code>Integrals.VEGASMC</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VEGASMC(; kws...)</code></pre><p>Markov-chain based Vegas algorithm from MCIntegration.jl</p><p>Refer to <a href="https://numericaleft.github.io/MCIntegration.jl/dev/lib/montecarlo/#MCIntegration.integrate-Tuple%7BFunction%7D"><code>MCIntegration.integrate</code></a> for documentation on the keywords, which are passed directly to the solver with a set of defaults that works for conforming integrands.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Integrals.jl/blob/409acc3a639c84cf066d448f1491c5027c15a32c/src/algorithms_extension.jl#L266-L275">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Integrals.CubaVegas" href="#Integrals.CubaVegas"><code>Integrals.CubaVegas</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CubaVegas()</code></pre><p>Multidimensional adaptive Monte Carlo integration from Cuba.jl. Importance sampling is used to reduce variance.</p><p><strong>References</strong></p><pre><code class="language-tex hljs">@article{lepage1978new,
title={A new algorithm for adaptive multidimensional integration},
author={Lepage, G Peter},
journal={Journal of Computational Physics},
volume={27},
number={2},
pages={192--203},
year={1978},
publisher={Elsevier}
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Integrals.jl/blob/409acc3a639c84cf066d448f1491c5027c15a32c/src/algorithms_extension.jl#L23-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Integrals.CubaSUAVE" href="#Integrals.CubaSUAVE"><code>Integrals.CubaSUAVE</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CubaSUAVE()</code></pre><p>Multidimensional adaptive Monte Carlo integration from Cuba.jl. Suave stands for subregion-adaptive VEGAS. Importance sampling and subdivision are thus used to reduce variance.</p><p><strong>References</strong></p><pre><code class="language-tex hljs">@article{hahn2005cuba,
title={Cuba—a library for multidimensional numerical integration},
author={Hahn, Thomas},
journal={Computer Physics Communications},
volume={168},
number={2},
pages={78--95},
year={2005},
publisher={Elsevier}
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Integrals.jl/blob/409acc3a639c84cf066d448f1491c5027c15a32c/src/algorithms_extension.jl#L53-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Integrals.CubaDivonne" href="#Integrals.CubaDivonne"><code>Integrals.CubaDivonne</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CubaDivonne()</code></pre><p>Multidimensional adaptive Monte Carlo integration from Cuba.jl. Stratified sampling is used to reduce variance.</p><p><strong>References</strong></p><pre><code class="language-tex hljs">@article{friedman1981nested,
title={A nested partitioning procedure for numerical multiple integration},
author={Friedman, Jerome H and Wright, Margaret H},
journal={ACM Transactions on Mathematical Software (TOMS)},
volume={7},
number={1},
pages={76--92},
year={1981},
publisher={ACM New York, NY, USA}
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Integrals.jl/blob/409acc3a639c84cf066d448f1491c5027c15a32c/src/algorithms_extension.jl#L84-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Integrals.CubaCuhre" href="#Integrals.CubaCuhre"><code>Integrals.CubaCuhre</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CubaCuhre()</code></pre><p>Multidimensional h-adaptive integration from Cuba.jl.</p><p><strong>References</strong></p><pre><code class="language-tex hljs">@article{berntsen1991adaptive,
title={An adaptive algorithm for the approximate calculation of multiple integrals},
author={Berntsen, Jarle and Espelid, Terje O and Genz, Alan},
journal={ACM Transactions on Mathematical Software (TOMS)},
volume={17},
number={4},
pages={437--451},
year={1991},
publisher={ACM New York, NY, USA}
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Integrals.jl/blob/409acc3a639c84cf066d448f1491c5027c15a32c/src/algorithms_extension.jl#L122-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Integrals.GaussLegendre" href="#Integrals.GaussLegendre"><code>Integrals.GaussLegendre</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GaussLegendre{C, N, W}</code></pre><p>Struct for evaluating an integral via (composite) Gauss-Legendre quadrature. The field <code>C</code> will be <code>true</code> if <code>subintervals &gt; 1</code>, and <code>false</code> otherwise.</p><p>The fields <code>nodes::N</code> and <code>weights::W</code> are defined by <code>nodes, weights = gausslegendre(n)</code> for a given number of nodes <code>n</code>.</p><p>The field <code>subintervals::Int64 = 1</code> (with default value <code>1</code>) defines the number of intervals to partition the original interval of integration <code>[a, b]</code> into, splitting it into <code>[xⱼ, xⱼ₊₁]</code> for <code>j = 1,…,subintervals</code>, where <code>xⱼ = a + (j-1)h</code> and <code>h = (b-a)/subintervals</code>. Gauss-Legendre quadrature is then applied on each subinterval. For example, if <code>[a, b] = [-1, 1]</code> and <code>subintervals = 2</code>, then Gauss-Legendre quadrature will be applied separately on <code>[-1, 0]</code> and <code>[0, 1]</code>, summing the two results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Integrals.jl/blob/409acc3a639c84cf066d448f1491c5027c15a32c/src/algorithms.jl#L111-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Integrals.QuadratureRule" href="#Integrals.QuadratureRule"><code>Integrals.QuadratureRule</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuadratureRule(q; n=250)</code></pre><p>Algorithm to construct and evaluate a quadrature rule <code>q</code> of <code>n</code> points computed from the inputs as <code>x, w = q(n)</code>. It assumes the nodes and weights are for the standard interval <code>[-1, 1]^d</code> in <code>d</code> dimensions, and rescales the nodes to the specific hypercube being solved. The nodes <code>x</code> may be scalars in 1d or vectors in arbitrary dimensions, and the weights <code>w</code> must be scalar. The algorithm computes the quadrature rule <code>sum(w .* f.(x))</code> and the caller must check that the result is converged with respect to <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Integrals.jl/blob/409acc3a639c84cf066d448f1491c5027c15a32c/src/algorithms.jl#L151-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Integrals.ArblibJL" href="#Integrals.ArblibJL"><code>Integrals.ArblibJL</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ArblibJL(; check_analytic=false, take_prec=false, warn_on_no_convergence=false, opts=C_NULL)</code></pre><p>One-dimensional adaptive Gauss-Legendre integration using rigorous error bounds and precision ball arithmetic. Generally this assumes the integrand is holomorphic or meromorphic, which is the user&#39;s responsibility to verify. The result of the integral is not guaranteed to satisfy the requested tolerances, however the result is guaranteed to be within the error estimate.</p><p><a href="https://github.com/kalmarek/Arblib.jl">Arblib.jl</a> only supports integration of univariate real- and complex-valued functions with both inplace and out-of-place forms. See their documentation for additional details the algorithm arguments and on implementing high-precision integrands. Additionally, the error estimate is included in the return value of the integral, representing a ball.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/Integrals.jl/blob/409acc3a639c84cf066d448f1491c5027c15a32c/src/algorithms_extension.jl#L238-L252">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../basics/FAQ/">« Frequently Asked Questions</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 17 October 2025 10:56">Friday 17 October 2025</span>. Using Julia version 1.12.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
